<?php ?>
<!DOCTYPE html>

<html lang="en">
<head>
  <meta charset="utf-8">
  
  <title>HOw GPS Works</title>
  <meta name="description" content="A project about GPS">
  <meta name="keywords" content="Satellite, navigation, Android,  GPS">  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <link rel="stylesheet" media="all" href="gpsstyle.css">

</head>
<body class="article tutorial">

  <header class="main" id="siteheader">
    <h1 id="title">
     http://html5test.com/index.html
    </h1>
    <a href="#sitenav" id="navtoggle">Show</a>

    
    <a id="toctoggle" href="#toc">Table of Contents</a>
    

  

<nav id="sitenav">
<table class='BannerTableStyle'>
<tr>
<td>
<img src="220px-ConstellationGPS.gif" alt = "GPS Animation"></td>
<td>Don's GPS<br/>Resource</td>
</tr>
</table>
      <ul>
        
        <li id="home_menu"><a href="/login" class="home">Home</a></li>
        <li id="login_menu"><a href="/resources" class="tutorials">Android GPS Resources</a></li>
        <li id="register_menu"><a href="/code" class="updates">Some Android GPS Java Code</a></li>
        <li id="animals_menu"><a href="/usegps" class="slides">Using GPS</a></li>
      </ul>
    </nav>

    
    <nav class="toc" id="toc">
      <h1>Table of Contents</h1>

      <ul><li><a href='#toc-introduction'>Introduction</a></li><li><a href='#toc-introduction-differences'>Server-Sent Events</a></li><li><a href='#toc-js-api'>JavaScript API</a></li><li><a href='#toc-event-stream-format'>Event Stream Format</a></li><li><a href='#toc-server-code'>Server Examples</a></li><li><a href='#toc-canceling'>Cancel an Event Stream</a></li><li><a href='#toc-security'>A Word on Security</a></li></ul>

     
    </nav>
    
  </header>





  <div class="body-content">
    

  <section class="title">

    

    <section class="PageHeading"> 
      
      <h1>Stream Updates with Events</h1>
      
      

     
    </section>
  </section>

  <article class="content-wrapper">

    <section class="container">

      

      <div class="article-meta" id="article-meta">
        <nav class="toc">
          <h1>Table of Contents</h1>

          <ul><li><a href='#toc-introduction'>Introduction</a></li>
<li><a href='#toc-introduction-differences'>Server-Sent</a></li>
<li><a href='#toc-js-api'>JavaScript API</a></li>
<li><a href='#toc-event-stream-format'>Event Stream</a></li>
<li><a href='#toc-server-code'>Server Examples</a></li>
<li><a href='#toc-canceling'>Cancel an Event</a></li></ul>
        </nav>

        
      </div>
       

      <div class="content" id="article-content"> 


        
  <h2 id="toc-introduction">Introduction</h2>
  <p>I wouldn't be surprised if you've stumbled on this article wondering, "What the heck are
  <a href="http://dev.w3.org/html5/eventsource/">Server-Sent Events</a> (<abbr title="Server-Sent Events">SSE</abbr>s)?" Many people
  have never heard of them, and rightfully so. Over the years, the specification has seen significant
  changes, and the API has taken somewhat of a backseat to newer, sexier communication
  protocols such as the <a href="/tutorials/#websockets">WebSocket API</a>. The idea behind
  <abbr title="Server-Sent Events">SSE</abbr>s may be familiar: a web app "subscribes" to a
  stream of updates generated by a server and, whenever a new event occurs, a notification is sent to
  the client. But to really understand Server-Sent Events, we need to understand the limitations
  of its AJAX predecessors, which includes:</p>

  <p><strong>Polling</strong> is a traditional technique used by the vast majority of AJAX applications.
  The basic idea is that the application repeatedly polls a server for data.
  If you're familiar with the HTTP protocol, you know that fetching data revolves around a request/response format.
  The client makes a request and waits for the server to respond with data. If none is available, an empty response
  is returned. So what's the big deal with polling? Extra polling creates greater HTTP overhead.</p>

  <p><strong>Long polling (Hanging GET / COMET)</strong> is a slight variation on polling.
  In long polling, if the server does not have data available, the server holds the request
  open until new data is made available. Hence, this technique is often referred to as a "Hanging GET".
  When information becomes available, the server responds, closes the connection, and the process is repeated.
  The effect is that the server is constantly responding with new data as it becomes available.
  The shortcoming is that the implementation of such a procedure typically involves hacks such
  as appending script tags to an 'infinite' iframe. We can do better than hacks!</p>

  <p>Server-Sent Events on the other hand, have been designed from the ground up to be efficient.
  When communicating using <abbr title="Server-Sent Events">SSE</abbr>s, a server can push data to your
  app whenever it wants, without the need to make an initial request. In other words,
  updates can be streamed from server to client as they happen. <abbr title="Server-Sent Events">SSE</abbr>s
  open a single unidirectional channel between server and client.</p>

  <p>The main difference between Server-Sent Events and long-polling is that <abbr title="Server-Sent Events">SSE</abbr>s
  are handled directly by the browser and the user simply has to listen for messages.</p>

  <h2 id="toc-introduction-differences">Server-Sent Events vs. WebSockets</h2>

  <p>Why would you choose Server-Sent Events over WebSockets? Good question.</p>

  <p>One reason <abbr title="Server-Sent Events">SSE</abbr>s have been kept in the shadow is because
  later APIs like <a href="/tutorials/#websockets">WebSockets</a> provide a richer protocol to perform bi-directional,
  full-duplex communication. Having a two-way channel is more attractive for things like games, messaging apps, and for
  cases where you need near real-time updates in both
  directions. However, in some scenarios <i>data doesn't need to be sent from the client</i>. You simply
  need updates from some server action. A few examples would be friends' status updates, stock tickers,
  news feeds, or other automated data push mechanisms (e.g. updating a client-side
  Web SQL Database or IndexedDB object store). If you'll need to send data to a server,
  <code>XMLHttpRequest</code> is always a friend.</p>

  

  <p>When updates are pushed from the server, the <code>onmessage</code> handler fires
  and new data is be available in its <code>e.data</code> property. The magical part is
  that whenever the connection is closed, the browser will automatically reconnect to the
  source after ~3 seconds. Your server implementation can even have control over
  this reconnection timeout. See <a href="#toc-reconnection-timeout">Controlling the reconnection-timeout</a>
  in the next section.</p>

  <p>That's it. Your client is now ready to process events from <code>stream.php</code>.</p>

  
 </div>
    </section>
  </article>
 

      <footer>
<p>Don O'Brien  2014</p> 
<p>donald_ob@hotmail.com</p>
<p>Thanks to Google and the HTML5 Rocks site for code and layout ideas through the <a href = "http://creativecommons.org/licenses/by/3.0/" target="_blank" >Creative Commons Attribution 3.0 License.</a></p>    
<p><a href = "http://en.wikipedia.org/wiki/File:ConstellationGPS.gif">GPS animation</a> courtesy of Wikipedia<p> 
</footer>

 </div>



</body>

<script>
    (function() {
    var site_Header = document.getElementById('siteheader');
    var nav_Toggle = document.getElementById('navtoggle');
    var site_Nav = document.getElementById('sitenav');

    function toggle(target, forceActive) {

      if (typeof toc !== 'undefined') {
        // Switch off the one that is not the current target
        if (target === toc)
          site_Nav.classList.remove('active');
        else
          toc.classList.remove('active');
      }

      // Toggle if no force parameter is set
      if (typeof forceActive === 'undefined') {
        target.classList.toggle('active');
      } else {
        if (forceActive)
          target.classList.add('active');
        else
          target.classList.remove('active');
      }

      // now find out what the set state ended up being
      var isActive = target.classList.contains('active');

      if (isActive)
        site_Header.classList.add('expanded');
      else
        site_Header.classList.remove('expanded');

    }

    nav_Toggle.addEventListener('click', function(e) {
      toggle(site_Nav);
      e.preventDefault();
    });

    

    var tocToggle = document.getElementById('toctoggle');
    var toc = document.getElementById('toc');
    var this_article_Meta = document.getElementById('article-meta');
    var this_article_Content = document.getElementById('article-content');
    var this_article_MetaHeight = 0;
    var this_article_MetaMaxY = 0;
    var this_article_MetaMinY = 0;
    var this_article_ContentPadding = 200;

    var tocLinks = document.querySelectorAll('.toc a');
    for (var t = 0; t < tocLinks.length; t++)
      tocLinks[t].addEventListener('click', onTocLinkGetClick);

    tocToggle.addEventListener('click', function(e) {
      toggle(toc);
      e.preventDefault();
    });

    toc.addEventListener('click', function(e) {
      if (e.target !== site_Nav)
        toggle(toc, false);
    });

    function onTocLinkGetClick() {
      _gag.push(['_trackEvent', 'Interactions', 'TOC', 'TOC Clicked']);
    }

    function setMinYScroll_FromMetaY() {
      var scrollPosition = window.scrollY;

      var this_article_MetaBounds = this_article_Meta.getBoundingClientRect();
      var this_article_MetaTop = Math.max(352,
          this_article_MetaBounds.top - 20 + scrollPosition);

      this_article_MetaHeight = this_article_MetaBounds.bottom - this_article_MetaBounds.top;
      this_article_MetaMinY = this_article_MetaTop;
    }

    function set_MaxYScroll_FromContentHeight() {

      var scrollPosition = window.scrollY;

      var this_article_ContentBounds = this_article_Content.getBoundingClientRect();
      var this_article_ContentTop = this_article_ContentBounds.top + scrollPosition;
      var this_article_ContentHeight = this_article_ContentBounds.bottom - this_article_ContentBounds.top;

      this_article_MetaMaxY = this_article_ContentTop +
          this_article_ContentHeight -
          this_article_MetaHeight -
          this_article_ContentPadding;

    }

    function onScroll(e) {

      if (window.scrollY >= this_article_MetaMinY) {

        this_article_Meta.classList.add('sticky');

        var this_article_MetaTop = 22 - Math.max(0, window.scrollY - this_article_MetaMaxY);
        this_article_Meta.style.top = this_article_MetaTop + 'px';

      } else {
        this_article_Meta.classList.remove('sticky');
        this_article_Meta.style.top = 'auto';
      }
    }

    if (this_article_Meta.getBoundingClientRect) {
      setMinYScroll_FromMetaY();
      set_MaxYScroll_FromContentHeight();
      document.addEventListener('scroll', onScroll);
      window.addEventListener('load', set_MaxYScroll_FromContentHeight, false);
    }

    
  })();

</script>
</html>
<?php exit; ?>
